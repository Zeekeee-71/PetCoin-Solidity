// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable2Step.sol";

contract PaymentSplitterReceiver is ReentrancyGuard, Ownable2Step {
    using SafeERC20 for IERC20;

    address public dev;
    address public liquidity;

    // token => allowed
    mapping(address => bool) public isAllowedToken;

    // token == address(0) means native coin (ETH / xDAI)
    event PaymentReceived(
        uint256 indexed ref,
        address indexed payer,
        address indexed token,
        uint256 grossAmount,
        uint256 devAmount,
        uint256 liqAmount,
        address devRecipient,
        address liqRecipient
    );

    error TokenNotAllowed();
    error ZeroAmount();
    error BadRecipient();

    constructor(address _dev, address _liquidity, address[] memory allowedTokens) {
        if (_dev == address(0) || _liquidity == address(0)) revert BadRecipient();
        dev = _dev;
        liquidity = _liquidity;

        // address(0) allowedTokens entry means "allow native"
        for (uint256 i = 0; i < allowedTokens.length; i++) {
            isAllowedToken[allowedTokens[i]] = true;
        }
    }

    function setAllowedToken(address token, bool allowed) external onlyOwner {
        isAllowedToken[token] = allowed;
    }

    function payNative(uint256 ref) external payable nonReentrant {
        if (!isAllowedToken[address(0)]) revert TokenNotAllowed();
        uint256 gross = msg.value;
        if (gross == 0) revert ZeroAmount();

        (uint256 d, uint256 l) = _split(gross);

        (bool ok1, ) = dev.call{value: d}("");
        require(ok1, "DEV_TRANSFER_FAILED");

        (bool ok2, ) = liquidity.call{value: l}("");
        require(ok2, "LIQ_TRANSFER_FAILED");

        emit PaymentReceived(ref, msg.sender, address(0), gross, d, l, dev, liquidity);
    }

    function payToken(uint256 ref, address token, uint256 amount) external nonReentrant {
        if (!isAllowedToken[token]) revert TokenNotAllowed();
        if (amount == 0) revert ZeroAmount();

        IERC20 t = IERC20(token);

        // pull funds in
        t.safeTransferFrom(msg.sender, address(this), amount);

        (uint256 d, uint256 l) = _split(amount);

        // split out
        t.safeTransfer(dev, d);
        t.safeTransfer(liquidity, l);

        emit PaymentReceived(ref, msg.sender, token, amount, d, l, dev, liquidity);
    }

    function _split(uint256 gross) internal pure returns (uint256 devAmt, uint256 liqAmt) {
        // 20% dev, remainder to liquidity to avoid dust loss
        devAmt = gross / 20;
        liqAmt = gross - devAmt;
    }

    receive() external payable {
        // Force people through payNative so you always get ref + event.
        revert("USE_payNative");
    }
}
